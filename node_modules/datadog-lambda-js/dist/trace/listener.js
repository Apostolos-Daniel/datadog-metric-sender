"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (g && (g = 0, op[0] && (_ = 0)), _) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
var __values = (this && this.__values) || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.TraceListener = void 0;
var patch_http_1 = require("./patch-http");
var trigger_1 = require("./trigger");
var cold_start_tracer_1 = require("./cold-start-tracer");
var utils_1 = require("../utils");
var cold_start_1 = require("../utils/cold-start");
var constants_1 = require("../constants");
var constants_2 = require("./constants");
var patch_console_1 = require("./patch-console");
var tracer_wrapper_1 = require("./tracer-wrapper");
var span_inferrer_1 = require("./span-inferrer");
var span_wrapper_1 = require("./span-wrapper");
var index_1 = require("../runtime/index");
var trace_context_service_1 = require("./trace-context-service");
var step_function_service_1 = require("./step-function-service");
var xray_service_1 = require("./xray-service");
var http_1 = require("./context/extractors/http");
var span_pointers_1 = require("../utils/span-pointers");
var TraceListener = /** @class */ (function () {
    function TraceListener(config) {
        this.config = config;
        this.tracerWrapper = new tracer_wrapper_1.TracerWrapper();
        this.contextService = new trace_context_service_1.TraceContextService(this.tracerWrapper, this.config);
        this.inferrer = new span_inferrer_1.SpanInferrer(this.tracerWrapper);
    }
    Object.defineProperty(TraceListener.prototype, "currentTraceHeaders", {
        get: function () {
            return this.contextService.currentTraceHeaders;
        },
        enumerable: false,
        configurable: true
    });
    TraceListener.prototype.onStartInvocation = function (event, context) {
        var _a;
        return __awaiter(this, void 0, void 0, function () {
            var tracerInitialized, spanContextWrapper, parentSpanContext, eventSource;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        tracerInitialized = this.tracerWrapper.isTracerAvailable;
                        if (this.config.injectLogContext) {
                            (0, patch_console_1.patchConsole)(console, this.contextService);
                            (0, utils_1.logDebug)("Patched console output with trace context");
                        }
                        else {
                            (0, utils_1.logDebug)("Didn't patch console output with trace context");
                        }
                        // If the DD tracer is initialized then it's doing http patching so we don't again here
                        if (this.config.autoPatchHTTP && !tracerInitialized) {
                            (0, utils_1.logDebug)("Patching HTTP libraries");
                            (0, patch_http_1.patchHttp)(this.contextService);
                        }
                        else {
                            (0, utils_1.logDebug)("Not patching HTTP libraries", { autoPatchHTTP: this.config.autoPatchHTTP, tracerInitialized: tracerInitialized });
                        }
                        return [4 /*yield*/, this.contextService.extract(event, context)];
                    case 1:
                        spanContextWrapper = _b.sent();
                        if (this.contextService.traceSource === trace_context_service_1.TraceSource.Event || this.config.mergeDatadogXrayTraces) {
                            parentSpanContext = tracerInitialized ? spanContextWrapper === null || spanContextWrapper === void 0 ? void 0 : spanContextWrapper.spanContext : undefined;
                            (0, utils_1.logDebug)("Attempting to find parent for the aws.lambda span");
                        }
                        else {
                            (0, utils_1.logDebug)("Didn't attempt to find parent for aws.lambda span", {
                                mergeDatadogXrayTraces: this.config.mergeDatadogXrayTraces,
                                traceSource: this.contextService.traceSource,
                            });
                        }
                        if (this.config.createInferredSpan) {
                            this.inferredSpan = this.inferrer.createInferredSpan(event, context, parentSpanContext, this.config.encodeAuthorizerContext);
                        }
                        this.lambdaSpanParentContext = ((_a = this.inferredSpan) === null || _a === void 0 ? void 0 : _a.span) || parentSpanContext;
                        this.context = context;
                        eventSource = (0, trigger_1.parseEventSource)(event);
                        this.triggerTags = (0, trigger_1.extractTriggerTags)(event, context, eventSource);
                        this.stepFunctionContext = step_function_service_1.StepFunctionContextService.instance().context;
                        this.spanPointerAttributesList = (0, span_pointers_1.getSpanPointerAttributes)(eventSource, event);
                        return [2 /*return*/];
                }
            });
        });
    };
    /**
     * onEndingInvocation runs after the user function has returned
     * but before the wrapped function has returned
     * this is needed to apply tags to the lambda span
     * before it is flushed to logs or extension
     *
     * @param event
     * @param result
     * @param shouldTagPayload
     */
    TraceListener.prototype.onEndingInvocation = function (event, result, isResponseStreamFunction) {
        var e_1, _a;
        var _b, _c;
        // Guard clause if something has gone horribly wrong
        // so we won't crash user code.
        if (!this.tracerWrapper.currentSpan)
            return false;
        this.wrappedCurrentSpan = new span_wrapper_1.SpanWrapper(this.tracerWrapper.currentSpan, {});
        if (this.config.captureLambdaPayload) {
            (0, utils_1.tagObject)(this.tracerWrapper.currentSpan, "function.request", event, 0, this.config.captureLambdaPayloadMaxDepth);
            (0, utils_1.tagObject)(this.tracerWrapper.currentSpan, "function.response", result, 0, this.config.captureLambdaPayloadMaxDepth);
        }
        var coldStartNodes = (0, index_1.getTraceTree)();
        if (coldStartNodes.length > 0) {
            var coldStartConfig = {
                tracerWrapper: this.tracerWrapper,
                parentSpan: (0, cold_start_1.didFunctionColdStart)() || (0, cold_start_1.isProactiveInitialization)()
                    ? this.inferredSpan || this.wrappedCurrentSpan
                    : this.wrappedCurrentSpan,
                lambdaFunctionName: (_b = this.context) === null || _b === void 0 ? void 0 : _b.functionName,
                currentSpanStartTime: (_c = this.wrappedCurrentSpan) === null || _c === void 0 ? void 0 : _c.startTime(),
                minDuration: this.config.minColdStartTraceDuration,
                ignoreLibs: this.config.coldStartTraceSkipLib,
                isColdStart: (0, cold_start_1.didFunctionColdStart)() || (0, cold_start_1.isProactiveInitialization)(),
            };
            var coldStartTracer = new cold_start_tracer_1.ColdStartTracer(coldStartConfig);
            coldStartTracer.trace(coldStartNodes);
            (0, index_1.clearTraceTree)();
        }
        if (this.triggerTags) {
            var statusCode = (0, trigger_1.extractHTTPStatusCodeTag)(this.triggerTags, result, isResponseStreamFunction);
            // Store the status tag in the listener to send to Xray on invocation completion
            this.triggerTags["http.status_code"] = statusCode;
            if (this.tracerWrapper.currentSpan) {
                this.tracerWrapper.currentSpan.setTag("http.status_code", statusCode);
            }
            if (this.inferredSpan) {
                this.inferredSpan.setTag("http.status_code", statusCode);
                if ((statusCode === null || statusCode === void 0 ? void 0 : statusCode.length) === 3 && (statusCode === null || statusCode === void 0 ? void 0 : statusCode.startsWith("5"))) {
                    this.wrappedCurrentSpan.setTag("error", 1);
                    return true;
                }
            }
        }
        if (this.wrappedCurrentSpan && this.spanPointerAttributesList) {
            try {
                for (var _d = __values(this.spanPointerAttributesList), _e = _d.next(); !_e.done; _e = _d.next()) {
                    var attributes = _e.value;
                    this.wrappedCurrentSpan.span.addSpanPointer(attributes.kind, attributes.direction, attributes.hash);
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_e && !_e.done && (_a = _d.return)) _a.call(_d);
                }
                finally { if (e_1) throw e_1.error; }
            }
        }
        return false;
    };
    TraceListener.prototype.injectAuthorizerSpan = function (result, requestId, finishTime) {
        var _a;
        var _b, _c;
        if (!result.context) {
            result.context = {};
        }
        var injectedHeaders = __assign(__assign({}, this.tracerWrapper.injectSpan(((_b = this.inferredSpan) === null || _b === void 0 ? void 0 : _b.span) || ((_c = this.wrappedCurrentSpan) === null || _c === void 0 ? void 0 : _c.span))), (_a = {}, _a[constants_2.parentSpanFinishTimeHeader] = finishTime * 1e6, _a));
        if (requestId) {
            //  undefined in token-type authorizer
            injectedHeaders[http_1.AUTHORIZING_REQUEST_ID_HEADER] = requestId;
        }
        result.context._datadog = Buffer.from(JSON.stringify(injectedHeaders)).toString("base64");
    };
    TraceListener.prototype.onCompleteInvocation = function (error, result, event) {
        var _a, _b, _c;
        return __awaiter(this, void 0, void 0, function () {
            var xray, tracerInitialized, finishTime;
            return __generator(this, function (_d) {
                // Create a new dummy Datadog subsegment for function trigger tags so we
                // can attach them to X-Ray spans when hybrid tracing is used
                if (this.triggerTags) {
                    xray = new xray_service_1.XrayService();
                    xray.addLambdaTriggerTags(this.triggerTags);
                }
                tracerInitialized = this.tracerWrapper.isTracerAvailable;
                if (this.config.autoPatchHTTP && !tracerInitialized) {
                    (0, utils_1.logDebug)("Unpatching HTTP libraries");
                    (0, patch_http_1.unpatchHttp)();
                }
                finishTime = (_a = this.wrappedCurrentSpan) === null || _a === void 0 ? void 0 : _a.endTime();
                if (this.inferredSpan) {
                    (0, utils_1.logDebug)("Finishing inferred span");
                    if (error && !this.inferredSpan.isAsync()) {
                        (0, utils_1.logDebug)("Setting error tag to inferred span");
                        this.inferredSpan.setTag("error", error);
                    }
                    if (this.inferredSpan.isAsync()) {
                        finishTime = ((_b = this.wrappedCurrentSpan) === null || _b === void 0 ? void 0 : _b.startTime()) || Date.now();
                    }
                    else {
                        finishTime = Date.now();
                    }
                    this.inferredSpan.finish(finishTime);
                }
                if (this.config.encodeAuthorizerContext && (result === null || result === void 0 ? void 0 : result.principalId) && (result === null || result === void 0 ? void 0 : result.policyDocument)) {
                    // We're in an authorizer, pass on the trace context, requestId and finishTime to make the authorizer span
                    this.injectAuthorizerSpan(result, (_c = event === null || event === void 0 ? void 0 : event.requestContext) === null || _c === void 0 ? void 0 : _c.requestId, finishTime || Date.now());
                }
                // Reset singleton
                this.stepFunctionContext = undefined;
                step_function_service_1.StepFunctionContextService.reset();
                return [2 /*return*/];
            });
        });
    };
    TraceListener.prototype.onWrap = function (func) {
        var _a, _b, _c;
        var options = {};
        if (this.context) {
            (0, utils_1.logDebug)("Creating the aws.lambda span");
            var functionArn = ((_a = this.context.invokedFunctionArn) !== null && _a !== void 0 ? _a : "").toLowerCase();
            var tk = functionArn.split(":");
            options.tags = {
                cold_start: (0, cold_start_1.didFunctionColdStart)(),
                function_arn: tk.length > 7 ? tk.slice(0, 7).join(":") : functionArn,
                function_version: tk.length > 7 ? tk[7] : "$LATEST",
                request_id: this.context.awsRequestId,
                resource_names: this.context.functionName,
                functionname: (_c = (_b = this.context) === null || _b === void 0 ? void 0 : _b.functionName) === null || _c === void 0 ? void 0 : _c.toLowerCase(),
                datadog_lambda: constants_1.datadogLambdaVersion,
                dd_trace: constants_2.ddtraceVersion,
            };
            if ((0, cold_start_1.isProactiveInitialization)()) {
                options.tags.proactive_initialization = true;
            }
            if ((this.contextService.traceSource === trace_context_service_1.TraceSource.Xray && this.config.mergeDatadogXrayTraces) ||
                this.contextService.traceSource === trace_context_service_1.TraceSource.Event) {
                options.tags["_dd.parent_source"] = this.contextService.traceSource;
            }
            if (this.triggerTags) {
                options.tags = __assign(__assign({}, options.tags), this.triggerTags);
            }
        }
        if (this.stepFunctionContext) {
            (0, utils_1.logDebug)("Applying step function context to the aws.lambda span");
            options.tags = __assign(__assign({}, options.tags), this.stepFunctionContext);
        }
        if (this.lambdaSpanParentContext) {
            options.childOf = this.lambdaSpanParentContext;
        }
        options.type = "serverless";
        options.service = "aws.lambda";
        if (this.context) {
            options.resource = this.context.functionName;
        }
        return this.tracerWrapper.wrap("aws.lambda", options, func);
    };
    return TraceListener;
}());
exports.TraceListener = TraceListener;
//# sourceMappingURL=listener.js.map