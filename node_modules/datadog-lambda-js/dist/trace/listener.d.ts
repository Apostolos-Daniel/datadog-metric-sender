import { Context } from "aws-lambda";
import { TraceContext } from "./trace-context-service";
export type TraceExtractor = (event: any, context: Context) => Promise<TraceContext> | TraceContext;
export interface TraceConfig {
    /**
     * Whether to automatically patch all outgoing http requests with Datadog's hybrid tracing headers.
     * @default true.
     */
    autoPatchHTTP: boolean;
    /**
     * Whether to capture the lambda payload and response in Datadog.
     */
    captureLambdaPayload: boolean;
    /**
     * The captured AWS Lambda payloads will become tags of the `aws.lambda` span. This sets how deep
     * it fathoms the JSON structure. When the max depth reached, the tag's value will be the
     * stringified value of the deeper nested items.
     */
    captureLambdaPayloadMaxDepth: number;
    /**
     * Whether to create inferred spans for managed services
     */
    createInferredSpan: boolean;
    /**
     * Whether to encode trace context in authorizer metadata
     */
    encodeAuthorizerContext: boolean;
    /**
     * Whether to decode trace context in authorizer metadata
     */
    decodeAuthorizerContext: boolean;
    /**
     * Whether to automatically patch console.log with Datadog's tracing ids.
     */
    injectLogContext: boolean;
    /**
     * Whether to merge traces produced from dd-trace with X-Ray
     * @default false
     */
    mergeDatadogXrayTraces: boolean;
    /**
     * Custom trace extractor function
     */
    traceExtractor?: TraceExtractor;
    /**
     * Minimum duration dependency to trace
     */
    minColdStartTraceDuration: number;
    /**
     * Libraries to ignore from cold start traces
     */
    coldStartTraceSkipLib: string;
}
export declare class TraceListener {
    private config;
    private contextService;
    private context?;
    private stepFunctionContext?;
    private tracerWrapper;
    private inferrer;
    private inferredSpan?;
    private wrappedCurrentSpan?;
    private triggerTags?;
    private lambdaSpanParentContext?;
    private spanPointerAttributesList;
    get currentTraceHeaders(): Partial<import(".").DatadogTraceHeaders>;
    constructor(config: TraceConfig);
    onStartInvocation(event: any, context: Context): Promise<void>;
    /**
     * onEndingInvocation runs after the user function has returned
     * but before the wrapped function has returned
     * this is needed to apply tags to the lambda span
     * before it is flushed to logs or extension
     *
     * @param event
     * @param result
     * @param shouldTagPayload
     */
    onEndingInvocation(event: any, result: any, isResponseStreamFunction: boolean): boolean;
    injectAuthorizerSpan(result: any, requestId: string, finishTime: number): any;
    onCompleteInvocation(error?: any, result?: any, event?: any): Promise<void>;
    onWrap<T = (...args: any[]) => any>(func: T): T;
}
//# sourceMappingURL=listener.d.ts.map