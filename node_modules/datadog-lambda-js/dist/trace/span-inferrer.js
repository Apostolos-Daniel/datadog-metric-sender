"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.SpanInferrer = void 0;
var trigger_1 = require("./trigger");
var span_wrapper_1 = require("./span-wrapper");
var constants_1 = require("./constants");
var utils_1 = require("../utils");
var extractors_1 = require("./context/extractors");
var http_1 = require("./context/extractors/http");
var SpanInferrer = /** @class */ (function () {
    function SpanInferrer(traceWrapper) {
        this.traceWrapper = traceWrapper;
        this.service = process.env[constants_1.DD_SERVICE_ENV_VAR];
        SpanInferrer.initServiceMapping();
    }
    SpanInferrer.initServiceMapping = function () {
        var _this = this;
        var serviceMappingStr = process.env.DD_SERVICE_MAPPING || "";
        serviceMappingStr.split(",").forEach(function (entry) {
            var parts = entry.split(":").map(function (part) { return part.trim(); });
            if (parts.length === 2 && parts[0] && parts[1] && parts[0] !== parts[1]) {
                _this.serviceMapping[parts[0]] = parts[1];
            }
        });
    };
    SpanInferrer.getServiceMapping = function (serviceName) {
        return this.serviceMapping[serviceName];
    };
    SpanInferrer.prototype.createInferredSpan = function (event, context, parentSpanContext, decodeAuthorizerContext) {
        if (decodeAuthorizerContext === void 0) { decodeAuthorizerContext = true; }
        var eventSource = (0, trigger_1.parseEventSource)(event);
        if (eventSource === trigger_1.eventTypes.lambdaUrl) {
            return this.createInferredSpanForLambdaUrl(event, context, parentSpanContext);
        }
        if (eventSource === trigger_1.eventTypes.apiGateway) {
            return this.createInferredSpanForApiGateway(event, context, parentSpanContext, decodeAuthorizerContext);
        }
        if (eventSource === trigger_1.eventTypes.sns) {
            return this.createInferredSpanForSns(event, context, parentSpanContext);
        }
        if (eventSource === trigger_1.eventTypes.dynamoDB) {
            return this.createInferredSpanForDynamoDBStreamEvent(event, context, parentSpanContext);
        }
        if (eventSource === trigger_1.eventTypes.sqs) {
            return this.createInferredSpanForSqs(event, context, parentSpanContext);
        }
        if (eventSource === trigger_1.eventTypes.kinesis) {
            return this.createInferredSpanForKinesis(event, context, parentSpanContext);
        }
        if (eventSource === trigger_1.eventTypes.s3) {
            return this.createInferredSpanForS3(event, context, parentSpanContext);
        }
        if (eventSource === trigger_1.eventTypes.eventBridge) {
            return this.createInferredSpanForEventBridge(event, context, parentSpanContext);
        }
    };
    SpanInferrer.prototype.isApiGatewayAsync = function (event) {
        if (event.headers && event.headers["X-Amz-Invocation-Type"] && event.headers["X-Amz-Invocation-Type"] === "Event") {
            return "async";
        }
        return "sync";
    };
    SpanInferrer.determineServiceName = function (specificKey, genericKey, fallback) {
        return this.serviceMapping[specificKey] || this.serviceMapping[genericKey] || fallback;
    };
    SpanInferrer.prototype.createInferredSpanForApiGateway = function (event, context, parentSpanContext, decodeAuthorizerContext) {
        if (decodeAuthorizerContext === void 0) { decodeAuthorizerContext = true; }
        var options = {};
        var domain = event.requestContext.domainName || "";
        var path = event.rawPath || event.requestContext.path || event.requestContext.routeKey;
        var resourcePath = this.getResourcePath(event);
        var method;
        if (event.requestContext.httpMethod) {
            method = event.requestContext.httpMethod;
        }
        else if (event.requestContext.http) {
            method = event.requestContext.http.method;
        }
        var resourceName = [method || domain, resourcePath].join(" ");
        var apiId = event.requestContext.apiId || "";
        var serviceName = SpanInferrer.determineServiceName(apiId, "lambda_api_gateway", domain);
        options.tags = {
            operation_name: "aws.apigateway",
            "http.url": domain + path,
            endpoint: path,
            resource_names: resourceName,
            request_id: context === null || context === void 0 ? void 0 : context.awsRequestId,
            service: serviceName,
            "service.name": serviceName,
            "span.type": "http",
            "resource.name": resourceName,
            "peer.service": this.service,
            apiid: apiId,
            _inferred_span: {
                tag_source: "self",
                synchronicity: this.isApiGatewayAsync(event),
            },
        };
        // Set APIGW v1 or v1 metadata
        if (method) {
            options.tags["http.method"] = method;
            options.tags.stage = event.requestContext.stage;
            options.tags.domain_name = domain;
        }
        // Set websocket metadata
        if (event.requestContext.messageDirection) {
            options.tags.message_direction = event.requestContext.messageDirection;
            options.tags.connection_id = event.requestContext.connectionId;
            options.tags.event_type = event.requestContext.eventType;
        }
        var upstreamAuthorizerSpan;
        var eventSourceSubType = extractors_1.HTTPEventTraceExtractor.getEventSubType(event);
        if (decodeAuthorizerContext) {
            try {
                var parsedUpstreamContext = extractors_1.HTTPEventTraceExtractor.getInjectedAuthorizerHeaders(event, eventSourceSubType);
                if (parsedUpstreamContext) {
                    var upstreamSpanOptions = {};
                    var startTime = parsedUpstreamContext[constants_1.parentSpanFinishTimeHeader] / 1e6;
                    // getting an approximated endTime
                    if (eventSourceSubType === http_1.HTTPEventSubType.ApiGatewayV2) {
                        options.startTime = startTime; // not inserting authorizer span
                        options.tags.operation_name = "aws.httpapi";
                    }
                    else {
                        upstreamSpanOptions = {
                            startTime: startTime,
                            childOf: parentSpanContext,
                            tags: __assign({ operation_name: "aws.apigateway.authorizer" }, options.tags),
                        };
                        upstreamAuthorizerSpan = new span_wrapper_1.SpanWrapper(this.traceWrapper.startSpan("aws.apigateway.authorizer", upstreamSpanOptions), { isAsync: false });
                        var endTime = event.requestContext.requestTimeEpoch + event.requestContext.authorizer.integrationLatency;
                        upstreamAuthorizerSpan.finish(endTime);
                        options.startTime = endTime; // For the main function's inferred span
                    }
                }
            }
            catch (error) {
                (0, utils_1.logDebug)("Error decoding authorizer span", error);
            }
        }
        if (!options.startTime) {
            if (eventSourceSubType === http_1.HTTPEventSubType.ApiGatewayV1 ||
                eventSourceSubType === http_1.HTTPEventSubType.ApiGatewayWebSocket) {
                options.startTime = event.requestContext.requestTimeEpoch;
            }
            else {
                options.startTime = event.requestContext.timeEpoch;
            }
        }
        options.childOf = upstreamAuthorizerSpan ? upstreamAuthorizerSpan.span : parentSpanContext;
        var spanWrapperOptions = {
            isAsync: this.isApiGatewayAsync(event) === "async",
        };
        return new span_wrapper_1.SpanWrapper(this.traceWrapper.startSpan("aws.apigateway", options), spanWrapperOptions);
    };
    SpanInferrer.prototype.createInferredSpanForLambdaUrl = function (event, context, parentSpanContext) {
        var options = {};
        var domain = event.requestContext.domainName || "";
        var path = event.rawPath;
        var method;
        if (event.requestContext.httpMethod) {
            method = event.requestContext.httpMethod;
        }
        else if (event.requestContext.http) {
            method = event.requestContext.http.method;
        }
        var resourceName = [method || domain, path].join(" ");
        var apiId = event.requestContext.apiId || "";
        var serviceName = SpanInferrer.determineServiceName(apiId, "lambda_url", domain);
        options.tags = {
            operation_name: "aws.lambda.url",
            "http.url": domain + path,
            endpoint: path,
            "http.method": event.requestContext.http.method,
            resource_names: resourceName,
            request_id: context === null || context === void 0 ? void 0 : context.awsRequestId,
            service: serviceName,
            "service.name": serviceName,
            "span.type": "http",
            "resource.name": resourceName,
            "peer.service": this.service,
            _inferred_span: {
                tag_source: "self",
                synchronicity: "sync",
            },
        };
        options.startTime = event.requestContext.timeEpoch;
        var spanWrapperOptions = {
            isAsync: false,
        };
        if (parentSpanContext) {
            options.childOf = parentSpanContext;
        }
        return new span_wrapper_1.SpanWrapper(this.traceWrapper.startSpan("aws.lambda.url", options), spanWrapperOptions);
    };
    SpanInferrer.prototype.createInferredSpanForDynamoDBStreamEvent = function (event, context, parentSpanContext) {
        var _a;
        var options = {};
        var Records = event.Records;
        var referenceRecord = Records[0];
        var eventSourceARN = referenceRecord.eventSourceARN, eventName = referenceRecord.eventName, eventVersion = referenceRecord.eventVersion, eventID = referenceRecord.eventID, dynamodb = referenceRecord.dynamodb;
        var _b = __read((eventSourceARN === null || eventSourceARN === void 0 ? void 0 : eventSourceARN.split("/")) || ["", ""], 2), tableArn = _b[0], tableName = _b[1];
        var resourceName = "".concat(eventName, " ").concat(tableName);
        var serviceName = SpanInferrer.determineServiceName(tableName, "lambda_dynamodb", "aws.dynamodb");
        options.tags = {
            operation_name: "aws.dynamodb",
            tablename: tableName,
            resource_names: resourceName,
            request_id: context === null || context === void 0 ? void 0 : context.awsRequestId,
            service: serviceName,
            "service.name": serviceName,
            "span.type": "web",
            "resource.name": resourceName,
            "peer.service": this.service,
            _inferred_span: {
                tag_source: "self",
                synchronicity: "async",
            },
            event_name: eventName,
            event_version: eventVersion,
            event_source_arn: eventSourceARN,
            event_id: eventID,
        };
        if (dynamodb) {
            options.tags.stream_view_type = dynamodb.StreamViewType;
            options.tags.size_bytes = dynamodb.SizeBytes;
        }
        if (parentSpanContext) {
            options.childOf = parentSpanContext;
        }
        options.startTime = Number((_a = referenceRecord.dynamodb) === null || _a === void 0 ? void 0 : _a.ApproximateCreationDateTime) * 1000;
        var spanWrapperOptions = {
            isAsync: true,
        };
        return new span_wrapper_1.SpanWrapper(this.traceWrapper.startSpan("aws.dynamodb", options), spanWrapperOptions);
    };
    SpanInferrer.prototype.createInferredSpanForSns = function (event, context, parentSpanContext) {
        var _a;
        var options = {};
        var referenceRecord;
        var eventSubscriptionArn = "";
        if (event.Records) {
            // Full SNS Event into Lambda
            var Records = event.Records;
            (_a = Records[0], referenceRecord = _a.Sns, eventSubscriptionArn = _a.EventSubscriptionArn);
        }
        else {
            // SNS message wrapping an SQS message
            referenceRecord = event;
        }
        var TopicArn = referenceRecord.TopicArn, Timestamp = referenceRecord.Timestamp, Type = referenceRecord.Type, Subject = referenceRecord.Subject, MessageId = referenceRecord.MessageId;
        var topicName = (TopicArn === null || TopicArn === void 0 ? void 0 : TopicArn.split(":").pop()) || "";
        var resourceName = topicName;
        var serviceName = SpanInferrer.determineServiceName(topicName, "lambda_sns", "sns");
        options.tags = {
            operation_name: "aws.sns",
            resource_names: resourceName,
            request_id: context === null || context === void 0 ? void 0 : context.awsRequestId,
            service: serviceName,
            "service.name": serviceName,
            "span.type": "sns",
            "resource.name": resourceName,
            "peer.service": this.service,
            _inferred_span: {
                tag_source: "self",
                synchronicity: "async",
            },
            type: Type,
            subject: Subject,
            message_id: MessageId,
            topicname: topicName,
            topic_arn: TopicArn,
        };
        // EventSubscriptionARN not available for direct integrations to SQS from SNS.
        if (eventSubscriptionArn !== "") {
            options.tags.event_subscription_arn = eventSubscriptionArn;
        }
        if (parentSpanContext) {
            options.childOf = parentSpanContext;
        }
        options.startTime = Date.parse(Timestamp);
        var spanWrapperOptions = {
            isAsync: true,
        };
        return new span_wrapper_1.SpanWrapper(this.traceWrapper.startSpan("aws.sns", options), spanWrapperOptions);
    };
    SpanInferrer.prototype.createInferredSpanForSqs = function (event, context, parentSpanContext) {
        var _a;
        var options = {};
        var Records = event.Records;
        var referenceRecord = Records[0];
        var _b = referenceRecord.attributes, SentTimestamp = _b.SentTimestamp, ApproximateReceiveCount = _b.ApproximateReceiveCount, SenderId = _b.SenderId, eventSourceARN = referenceRecord.eventSourceARN, receiptHandle = referenceRecord.receiptHandle, body = referenceRecord.body;
        var queueName = (eventSourceARN === null || eventSourceARN === void 0 ? void 0 : eventSourceARN.split(":").pop()) || "";
        var resourceName = queueName;
        var serviceName = SpanInferrer.determineServiceName(queueName, "lambda_sqs", "sqs");
        options.tags = {
            operation_name: "aws.sqs",
            resource_names: resourceName,
            request_id: context === null || context === void 0 ? void 0 : context.awsRequestId,
            service: serviceName,
            "service.name": serviceName,
            "span.type": "web",
            "resource.name": resourceName,
            "peer.service": this.service,
            _inferred_span: {
                tag_source: "self",
                synchronicity: "async",
            },
            queuename: queueName,
            event_source_arn: eventSourceARN,
            receipt_handle: receiptHandle,
            sender_id: SenderId,
        };
        if (ApproximateReceiveCount && Number(ApproximateReceiveCount) > 0) {
            options.tags.retry_count = Number(ApproximateReceiveCount);
        }
        // Check if sqs message was from sns
        // If so, unpack and look at timestamp
        // create further upstream sns span and finish/attach it here
        var upstreamSpan = null;
        try {
            var upstreamMessage = void 0;
            upstreamMessage = JSON.parse(body);
            if (upstreamMessage && upstreamMessage.TopicArn && upstreamMessage.Timestamp) {
                upstreamSpan = this.createInferredSpanForSns(upstreamMessage, context, parentSpanContext);
                upstreamSpan.finish(Number(SentTimestamp));
            }
            else if ((_a = upstreamMessage === null || upstreamMessage === void 0 ? void 0 : upstreamMessage.detail) === null || _a === void 0 ? void 0 : _a._datadog) {
                upstreamSpan = this.createInferredSpanForEventBridge(upstreamMessage, context, parentSpanContext);
                upstreamSpan.finish(Number(SentTimestamp));
            }
        }
        catch (e) {
            // Pass, it's a raw SQS message
        }
        options.childOf = upstreamSpan ? upstreamSpan.span : parentSpanContext;
        options.startTime = Number(SentTimestamp);
        var spanWrapperOptions = {
            isAsync: true,
        };
        return new span_wrapper_1.SpanWrapper(this.traceWrapper.startSpan("aws.sqs", options), spanWrapperOptions);
    };
    SpanInferrer.prototype.createInferredSpanForKinesis = function (event, context, parentSpanContext) {
        var options = {};
        var Records = event.Records;
        var referenceRecord = Records[0];
        var _a = referenceRecord.kinesis, approximateArrivalTimestamp = _a.approximateArrivalTimestamp, partitionKey = _a.partitionKey, eventSourceARN = referenceRecord.eventSourceARN, eventName = referenceRecord.eventName, eventVersion = referenceRecord.eventVersion, eventID = referenceRecord.eventID;
        var streamName = (eventSourceARN === null || eventSourceARN === void 0 ? void 0 : eventSourceARN.split(":").pop()) || "";
        var shardId = eventID.split(":").pop();
        var serviceName = SpanInferrer.determineServiceName(streamName, "lambda_kinesis", "kinesis");
        options.tags = {
            operation_name: "aws.kinesis",
            resource_names: streamName,
            request_id: context === null || context === void 0 ? void 0 : context.awsRequestId,
            service: serviceName,
            "service.name": serviceName,
            "span.type": "web",
            "resource.name": streamName,
            "peer.service": this.service,
            _inferred_span: {
                tag_source: "self",
                synchronicity: "async",
            },
            streamname: streamName,
            event_id: eventID,
            event_name: eventName,
            event_source_arn: eventSourceARN,
            event_version: eventVersion,
            partition_key: partitionKey,
            shardid: shardId,
        };
        if (parentSpanContext) {
            options.childOf = parentSpanContext;
        }
        options.startTime = Number(approximateArrivalTimestamp) * 1000;
        var spanWrapperOptions = {
            isAsync: true,
        };
        return new span_wrapper_1.SpanWrapper(this.traceWrapper.startSpan("aws.kinesis", options), spanWrapperOptions);
    };
    SpanInferrer.prototype.createInferredSpanForS3 = function (event, context, parentSpanContext) {
        var options = {};
        var Records = event.Records;
        var referenceRecord = Records[0];
        var _a = referenceRecord.s3, _b = _a.bucket, bucketName = _b.name, arn = _b.arn, _c = _a.object, key = _c.key, size = _c.size, eTag = _c.eTag, eventTime = referenceRecord.eventTime, eventName = referenceRecord.eventName;
        var serviceName = SpanInferrer.determineServiceName(bucketName, "lambda_s3", "s3");
        options.tags = {
            operation_name: "aws.s3",
            resource_names: bucketName,
            request_id: context === null || context === void 0 ? void 0 : context.awsRequestId,
            service: serviceName,
            "service.name": serviceName,
            "span.type": "web",
            "resource.name": bucketName,
            "peer.service": this.service,
            _inferred_span: {
                tag_source: "self",
                synchronicity: "async",
            },
            bucketname: bucketName,
            bucket_arn: arn,
            event_name: eventName,
            object_key: key,
            object_size: size,
            object_etag: eTag,
        };
        if (parentSpanContext) {
            options.childOf = parentSpanContext;
        }
        options.startTime = Date.parse(eventTime);
        var spanWrapperOptions = {
            isAsync: true,
        };
        return new span_wrapper_1.SpanWrapper(this.traceWrapper.startSpan("aws.s3", options), spanWrapperOptions);
    };
    SpanInferrer.prototype.createInferredSpanForEventBridge = function (event, context, parentSpanContext) {
        var options = {};
        var _a = event, time = _a.time, source = _a.source;
        var serviceName = SpanInferrer.determineServiceName(source, "lambda_eventbridge", "eventbridge");
        options.tags = {
            operation_name: "aws.eventbridge",
            resource_names: source,
            request_id: context === null || context === void 0 ? void 0 : context.awsRequestId,
            service: serviceName,
            "service.name": serviceName,
            "span.type": "web",
            "resource.name": source,
            "peer.service": this.service,
            _inferred_span: {
                tag_source: "self",
                synchronicity: "async",
            },
        };
        if (parentSpanContext) {
            options.childOf = parentSpanContext;
        }
        options.startTime = Date.parse(time);
        var spanWrapperOptions = {
            isAsync: true,
        };
        return new span_wrapper_1.SpanWrapper(this.traceWrapper.startSpan("aws.eventbridge", options), spanWrapperOptions);
    };
    SpanInferrer.prototype.getResourcePath = function (event) {
        var _a;
        var routeKey = (_a = event === null || event === void 0 ? void 0 : event.requestContext) === null || _a === void 0 ? void 0 : _a.routeKey;
        if (routeKey && routeKey.includes("{")) {
            // this is a parameterized route
            try {
                return event.requestContext.routeKey.split(" ")[1];
            }
            catch (e) {
                (0, utils_1.logDebug)("Error parsing routeKey", e);
            }
        }
        return event.rawPath || event.requestContext.resourcePath || routeKey;
    };
    SpanInferrer.serviceMapping = {};
    return SpanInferrer;
}());
exports.SpanInferrer = SpanInferrer;
//# sourceMappingURL=span-inferrer.js.map