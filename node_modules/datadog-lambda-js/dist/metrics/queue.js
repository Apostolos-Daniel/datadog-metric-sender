"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.MetricsQueue = exports.METRICS_QUEUE_LIMIT = void 0;
var utils_1 = require("../utils");
exports.METRICS_QUEUE_LIMIT = 1024;
/**
 * MetricsQueue is a queue for metrics that are enqueued when the MetricsListener is not initialized.
 *
 * When the MetricsListener is initialized, the metrics are sent to the listener for processing.
 * If the queue is full, all metrics are dropped, and new ones are enqueued. This might happen in two
 * scenarios:
 * 1. The MetricsListener is not initialized for a long time.
 * 2. The MetricsListener is initialized, but the amount of enqueued metrics is higher than the limit.
 */
var MetricsQueue = /** @class */ (function () {
    function MetricsQueue() {
        this.queue = [];
    }
    /**
     * Enqueues a metric for later processing.
     * If the queue is full, all metrics are dropped. But the new metric is still enqueued.
     *
     * @param metric The metric to be enqueued.
     */
    MetricsQueue.prototype.push = function (metric) {
        (0, utils_1.logDebug)("Metrics Listener was not initialized. Enqueuing metric for later processing.");
        if (this.queue.length >= exports.METRICS_QUEUE_LIMIT) {
            (0, utils_1.logWarning)("Metrics queue is full, dropping all metrics.");
            this.reset();
        }
        this.queue.push(metric);
    };
    MetricsQueue.prototype.pop = function () {
        if (this.queue.length > 0) {
            return this.queue.pop();
        }
        return undefined;
    };
    MetricsQueue.prototype.reverse = function () {
        this.queue.reverse();
    };
    MetricsQueue.prototype.reset = function () {
        this.queue = [];
    };
    Object.defineProperty(MetricsQueue.prototype, "length", {
        get: function () {
            return this.queue.length;
        },
        enumerable: false,
        configurable: true
    });
    return MetricsQueue;
}());
exports.MetricsQueue = MetricsQueue;
//# sourceMappingURL=queue.js.map