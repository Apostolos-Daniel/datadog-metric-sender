"use strict";
var __values = (this && this.__values) || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getSpanPointerAttributes = void 0;
var trigger_1 = require("../trace/trigger");
var log_1 = require("./log");
/**
 * Computes span pointer attributes
 *
 * @param {eventTypes} eventSource - The type of event being processed (e.g., S3, DynamoDB).
 * @param {any} event - The event object containing source-specific data.
 * @returns {SpanPointerAttributes[] | undefined} An array of span pointer attribute objects, or undefined if none could be computed.
 */
function getSpanPointerAttributes(eventSource, event) {
    if (!eventSource) {
        return;
    }
    switch (eventSource) {
        case trigger_1.eventTypes.s3:
            return processS3Event(event);
        case trigger_1.eventTypes.dynamoDB:
            return processDynamoDbEvent(event);
    }
}
exports.getSpanPointerAttributes = getSpanPointerAttributes;
function processS3Event(event) {
    var e_1, _a;
    var _b, _c, _d;
    var records = event.Records || [];
    var spanPointerAttributesList = [];
    // Get dependencies from tracer only when needed
    var S3_PTR_KIND;
    var SPAN_POINTER_DIRECTION;
    var generatePointerHash;
    try {
        var constants = require("dd-trace/packages/dd-trace/src/constants");
        var util = require("dd-trace/packages/datadog-plugin-aws-sdk/src/util");
        (S3_PTR_KIND = constants.S3_PTR_KIND, SPAN_POINTER_DIRECTION = constants.SPAN_POINTER_DIRECTION);
        (generatePointerHash = util.generatePointerHash);
    }
    catch (err) {
        if (err instanceof Error) {
            (0, log_1.logDebug)("Failed to load dd-trace span pointer dependencies", err);
        }
        return spanPointerAttributesList;
    }
    try {
        for (var records_1 = __values(records), records_1_1 = records_1.next(); !records_1_1.done; records_1_1 = records_1.next()) {
            var record = records_1_1.value;
            var eventName = record.eventName;
            if (!eventName || !eventName.startsWith("ObjectCreated")) {
                continue;
            }
            // Values are stored in the same place, regardless of AWS SDK v2/v3 or the event type.
            // https://docs.aws.amazon.com/AmazonS3/latest/userguide/notification-content-structure.html
            var s3Event = record === null || record === void 0 ? void 0 : record.s3;
            var bucketName = (_b = s3Event === null || s3Event === void 0 ? void 0 : s3Event.bucket) === null || _b === void 0 ? void 0 : _b.name;
            var objectKey = (_c = s3Event === null || s3Event === void 0 ? void 0 : s3Event.object) === null || _c === void 0 ? void 0 : _c.key;
            var eTag = (_d = s3Event === null || s3Event === void 0 ? void 0 : s3Event.object) === null || _d === void 0 ? void 0 : _d.eTag;
            if (!bucketName || !objectKey || !eTag) {
                (0, log_1.logDebug)("Unable to calculate span pointer hash because of missing parameters.");
                continue;
            }
            // https://github.com/DataDog/dd-span-pointer-rules/blob/main/AWS/S3/Object/README.md
            if (eTag.startsWith('"') && eTag.endsWith('"')) {
                eTag = eTag.slice(1, -1);
            }
            var pointerHash = generatePointerHash([bucketName, objectKey, eTag]);
            var spanPointerAttributes = {
                kind: S3_PTR_KIND,
                direction: SPAN_POINTER_DIRECTION.UPSTREAM,
                hash: pointerHash,
            };
            spanPointerAttributesList.push(spanPointerAttributes);
        }
    }
    catch (e_1_1) { e_1 = { error: e_1_1 }; }
    finally {
        try {
            if (records_1_1 && !records_1_1.done && (_a = records_1.return)) _a.call(records_1);
        }
        finally { if (e_1) throw e_1.error; }
    }
    return spanPointerAttributesList;
}
function processDynamoDbEvent(event) {
    var e_2, _a;
    var _b;
    var records = event.Records || [];
    var spanPointerAttributesList = [];
    // Get dependencies from tracer only when needed
    var DYNAMODB_PTR_KIND;
    var SPAN_POINTER_DIRECTION;
    var generatePointerHash;
    var extractPrimaryKeys;
    try {
        var constants = require("dd-trace/packages/dd-trace/src/constants");
        var util = require("dd-trace/packages/datadog-plugin-aws-sdk/src/util");
        (DYNAMODB_PTR_KIND = constants.DYNAMODB_PTR_KIND, SPAN_POINTER_DIRECTION = constants.SPAN_POINTER_DIRECTION);
        (generatePointerHash = util.generatePointerHash, extractPrimaryKeys = util.extractPrimaryKeys);
    }
    catch (err) {
        if (err instanceof Error) {
            (0, log_1.logDebug)("Failed to load dd-trace span pointer dependencies", err);
        }
        return spanPointerAttributesList;
    }
    try {
        for (var records_2 = __values(records), records_2_1 = records_2.next(); !records_2_1.done; records_2_1 = records_2.next()) {
            var record = records_2_1.value;
            var eventName = record.eventName;
            // Process INSERT, MODIFY, REMOVE events
            if (!["INSERT", "MODIFY", "REMOVE"].includes(eventName)) {
                continue;
            }
            var keys = (_b = record.dynamodb) === null || _b === void 0 ? void 0 : _b.Keys;
            var eventSourceARN = record.eventSourceARN;
            var tableName = record.eventSourceARN ? getTableNameFromARN(eventSourceARN) : undefined;
            if (!tableName || !keys) {
                (0, log_1.logDebug)("Unable to calculate hash because of missing parameters.");
                continue;
            }
            var keyNamesSet = new Set(Object.keys(keys));
            var primaryKeysAndValues = extractPrimaryKeys(keyNamesSet, keys);
            if (!primaryKeysAndValues) {
                continue;
            }
            var pointerHash = generatePointerHash(__spreadArray([tableName], __read(primaryKeysAndValues), false));
            var spanPointerAttributes = {
                kind: DYNAMODB_PTR_KIND,
                direction: SPAN_POINTER_DIRECTION.UPSTREAM,
                hash: pointerHash,
            };
            spanPointerAttributesList.push(spanPointerAttributes);
        }
    }
    catch (e_2_1) { e_2 = { error: e_2_1 }; }
    finally {
        try {
            if (records_2_1 && !records_2_1.done && (_a = records_2.return)) _a.call(records_2);
        }
        finally { if (e_2) throw e_2.error; }
    }
    return spanPointerAttributesList;
}
function getTableNameFromARN(arn) {
    // ARN format: arn:aws:dynamodb:<region>:<account-id>:table/<table-name>/stream/<YYYY-MM-DDThh:mm:ss.ms>
    var match = arn.match(/table\/([^\/]*)/);
    return match ? match[1] : undefined;
}
//# sourceMappingURL=span-pointers.js.map