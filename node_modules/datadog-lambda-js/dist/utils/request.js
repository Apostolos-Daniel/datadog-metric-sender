"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.get = exports.post = void 0;
var https_1 = __importDefault(require("https"));
var http_1 = __importDefault(require("http"));
var log_1 = require("./log");
var zlib_1 = require("zlib");
function post(url, body, options, compressPayload) {
    var bodyJSON = JSON.stringify(body);
    var buffer = Buffer.from(bodyJSON);
    if (compressPayload) {
        // Adding compression header
        options = options || {}; // Define options object if not already defined
        options.headers = __assign(__assign({}, options.headers), { "Content-Encoding": "deflate" });
        buffer = (0, zlib_1.deflateSync)(buffer);
    }
    (0, log_1.logDebug)("sending payload with body ".concat(bodyJSON));
    var requestOptions = __assign({ headers: { "content-type": "application/json" }, host: url.host, hostname: url.hostname, method: "POST", path: "".concat(url.pathname).concat(url.search), port: url.port, protocol: url.protocol }, options);
    return sendRequest(url, requestOptions, buffer);
}
exports.post = post;
function get(url, options) {
    var requestOptions = __assign({ headers: { "content-type": "application/json" }, host: url.host, hostname: url.hostname, method: "GET", path: "".concat(url.pathname).concat(url.search), port: url.port, protocol: url.protocol }, options);
    return sendRequest(url, requestOptions);
}
exports.get = get;
// This utility function returns NO data, as per the types indicate
// if a response body is needed, we can implement a listener
// response.on('data', cb)
// or call
// response.read()
// which can append data to a buffer and return it
function sendRequest(url, options, buffer) {
    return new Promise(function (resolve) {
        var requestMethod = url.protocol === "https:" ? https_1.default.request : http_1.default.request;
        var request = requestMethod(options, function (response) {
            var statusCode = response.statusCode;
            // https://nodejs.org/api/http.html#class-httpclientrequest
            // "Until the data is consumed, the 'end' event will not fire. Also, until the data is read it will consume memory that can eventually lead to a 'process out of memory' error"
            response.resume();
            if (statusCode === undefined || statusCode < 200 || statusCode > 299) {
                return resolve({
                    success: false,
                    statusCode: statusCode,
                    errorMessage: "HTTP error code: ".concat(response.statusCode),
                });
            }
            return resolve({
                success: true,
                statusCode: statusCode,
            });
        });
        request.once("error", function (error) {
            resolve({
                success: false,
                errorMessage: error.message,
            });
        });
        if (buffer) {
            request.write(buffer);
        }
        request.end();
    });
}
//# sourceMappingURL=request.js.map